'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var logger = require('./logger')(module);
var EventEmitter = require('events').EventEmitter;
var is = require('./is');
var enums = require('./enums');
var errorBooster = require('./error-booster');
var Job = require('./job');
var dbReview = require('./db-review');
var queueDb = require('./queue-db');
var queueProcess = require('./queue-process');
var queueAddJob = require('./queue-add-job');
var queueGetJob = require('./queue-get-job');
var queueFindJob = require('./queue-find-job');
var queueFindJobByName = require('./queue-find-job-by-name');
var queueInterruption = require('./queue-interruption');
var queueCancelJob = require('./queue-cancel-job');
var queueReanimateJob = require('./queue-reanimate-job');
var queueRemoveJob = require('./queue-remove-job');
var queueReset = require('./queue-reset');
var queueSummary = require('./queue-summary');
var queueStop = require('./queue-stop');
var queueDrop = require('./queue-drop');
var jobOptions = require('./job-options');

var Queue = function (_EventEmitter) {
  _inherits(Queue, _EventEmitter);

  function Queue(cxn, options) {
    _classCallCheck(this, Queue);

    var _this = _possibleConstructorReturn(this, (Queue.__proto__ || Object.getPrototypeOf(Queue)).call(this));

    logger('Queue Constructor', options);

    options = options || {};
    _this._name = options.name || enums.options.name;

    // The following properties are Populated
    // by the queueDb.attach(this, cxn) call below.
    _this._r = false;
    _this._host = '';
    _this._port = 0;
    _this._db = '';
    _this._id = '';
    _this._ready = false;

    _this._queryRunOptions = options.queryRunOptions == null ? enums.options.queryRunOptions : options.queryRunOptions;
    _this._masterInterval = options.masterInterval == null ? enums.options.masterInterval : options.masterInterval;
    _this._databaseInitDelay = options.databaseInitDelay == null ? enums.options.databaseInitDelay : options.databaseInitDelay;
    _this._jobOptions = jobOptions();
    _this._changeFeedCursor = false;
    _this._paused = false;
    _this._running = 0;
    _this._changeFeed = options.changeFeed == null ? true : options.changeFeed;
    _this._concurrency = options.concurrency > 1 ? options.concurrency : enums.options.concurrency;
    _this._limitJobLogs = options.limitJobLogs == null ? enums.options.limitJobLogs : options.limitJobLogs;
    _this._removeFinishedJobs = options.removeFinishedJobs == null ? enums.options.removeFinishedJobs : options.removeFinishedJobs;
    _this._handler = false;
    queueDb.attach(_this, cxn);
    return _this;
  }

  _createClass(Queue, [{
    key: 'createJob',
    value: function createJob(jobData) {
      logger('createJob', jobData);
      jobData = jobData == null ? this.jobOptions : jobData;
      return new Job(this, jobData);
    }
  }, {
    key: 'addJob',
    value: function addJob(job) {
      var _this2 = this;

      logger('addJob', job);
      return this.ready().then(function () {
        return queueAddJob(_this2, job);
      }).catch(errorBooster(this, logger, 'addJob'));
    }
  }, {
    key: 'getJob',
    value: function getJob(jobOrId) {
      var _this3 = this;

      logger('getJob', jobOrId);
      return this.ready().then(function () {
        return queueGetJob(_this3, jobOrId);
      }).catch(errorBooster(this, logger, 'getJob'));
    }
  }, {
    key: 'findJob',
    value: function findJob(predicate, raw) {
      var _this4 = this;

      logger('findJob', predicate, raw);
      return this.ready().then(function () {
        return queueFindJob(_this4, predicate, raw);
      }).catch(errorBooster(this, logger, 'findJob'));
    }
  }, {
    key: 'findJobByName',
    value: function findJobByName(name, raw) {
      var _this5 = this;

      logger('findJobByName', name, raw);
      return this.ready().then(function () {
        return queueFindJobByName(_this5, name, raw);
      }).catch(errorBooster(this, logger, 'findJobByName'));
    }
  }, {
    key: 'containsJobByName',
    value: function containsJobByName(name) {
      var _this6 = this;

      logger('containsJobByName', name);
      return this.ready().then(function () {
        return queueFindJobByName(_this6, name, true);
      }).then(function (namedJobs) {
        return namedJobs.length > 0;
      }).catch(errorBooster(this, logger, 'containsJobByName'));
    }
  }, {
    key: 'cancelJob',
    value: function cancelJob(jobOrId, reason) {
      var _this7 = this;

      logger('cancelJob', jobOrId, reason);
      return this.ready().then(function () {
        return queueCancelJob(_this7, jobOrId, reason);
      }).catch(errorBooster(this, logger, 'cancelJob'));
    }
  }, {
    key: 'reanimateJob',
    value: function reanimateJob(jobOrId, dateEnable) {
      var _this8 = this;

      logger('reanimateJob', jobOrId, dateEnable);
      return this.ready().then(function () {
        return queueReanimateJob(_this8, jobOrId, dateEnable);
      }).catch(errorBooster(this, logger, 'reanimateJob'));
    }
  }, {
    key: 'removeJob',
    value: function removeJob(jobOrId) {
      var _this9 = this;

      logger('removeJob', jobOrId);
      return this.ready().then(function () {
        return queueRemoveJob(_this9, jobOrId);
      }).catch(errorBooster(this, logger, 'removeJob'));
    }
  }, {
    key: 'process',
    value: function process(handler) {
      var _this10 = this;

      logger('process', handler);
      return this.ready().then(function () {
        return queueProcess.addHandler(_this10, handler);
      }).catch(errorBooster(this, logger, 'process'));
    }
  }, {
    key: 'review',
    value: function review() {
      var _this11 = this;

      logger('review');
      return this.ready().then(function () {
        return dbReview.runOnce(_this11);
      }).catch(errorBooster(this, logger, 'review'));
    }
  }, {
    key: 'summary',
    value: function summary() {
      var _this12 = this;

      logger('summary');
      return this.ready().then(function () {
        return queueSummary(_this12);
      }).catch(errorBooster(this, logger, 'summary'));
    }
  }, {
    key: 'ready',
    value: function ready() {
      logger('ready');
      return this._ready;
    }
  }, {
    key: 'pause',
    value: function pause(global) {
      var _this13 = this;

      logger('pause');
      return this.ready().then(function () {
        return queueInterruption.pause(_this13, global);
      }).catch(errorBooster(this, logger, 'pause'));
    }
  }, {
    key: 'resume',
    value: function resume(global) {
      var _this14 = this;

      logger('resume');
      return this.ready().then(function () {
        return queueInterruption.resume(_this14, global);
      }).catch(errorBooster(this, logger, 'resume'));
    }
  }, {
    key: 'reset',
    value: function reset() {
      var _this15 = this;

      logger('reset');
      return this.ready().then(function () {
        return queueReset(_this15);
      }).catch(errorBooster(this, logger, 'reset'));
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this16 = this;

      logger('stop');
      return queueStop(this).then(function () {
        return queueDb.drain(_this16);
      }).catch(errorBooster(this, logger, 'stop'));
    }
  }, {
    key: 'drop',
    value: function drop() {
      logger('drop');
      return queueDrop(this).catch(errorBooster(this, logger, 'drop'));
    }
  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'host',
    get: function get() {
      return this._host;
    }
  }, {
    key: 'port',
    get: function get() {
      return this._port;
    }
  }, {
    key: 'db',
    get: function get() {
      return this._db;
    }
  }, {
    key: 'r',
    get: function get() {
      return this._r;
    }
  }, {
    key: 'changeFeed',
    get: function get() {
      return this._changeFeed;
    }
  }, {
    key: 'master',
    get: function get() {
      return this._masterInterval > 0;
    }
  }, {
    key: 'masterInterval',
    get: function get() {
      return this._masterInterval;
    }
  }, {
    key: 'jobOptions',
    get: function get() {
      return this._jobOptions;
    },
    set: function set(options) {
      logger('set jobOptions', options);
      this._jobOptions = jobOptions(options, this._jobOptions);
    }
  }, {
    key: 'limitJobLogs',
    get: function get() {
      return this._limitJobLogs;
    }
  }, {
    key: 'removeFinishedJobs',
    get: function get() {
      return this._removeFinishedJobs;
    }
  }, {
    key: 'running',
    get: function get() {
      return this._running;
    }
  }, {
    key: 'concurrency',
    get: function get() {
      return this._concurrency;
    },
    set: function set(value) {
      logger('set concurrency', value);
      if (!is.integer(value) || value < 1) {
        var err = new Error(enums.message.concurrencyInvalid);
        err.queueId = this.id;
        logger('concurrency', this.id, err);
        this.emit(enums.status.error, err);
        return;
      }
      this._concurrency = value;
    }
  }, {
    key: 'paused',
    get: function get() {
      return this._paused;
    }
  }, {
    key: 'idle',
    get: function get() {
      return this._running < 1;
    }
  }]);

  return Queue;
}(EventEmitter);

// Make TypeScript compiler happy. Needed because Job is an abstract class.


Queue.Job = Job;

module.exports = Queue;