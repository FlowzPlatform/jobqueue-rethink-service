'use strict';

var logger = require('./logger')(module);
var Promise = require('bluebird');
var is = require('./is');
var datetime = require('./datetime');
var enums = require('./enums');
var jobLog = require('./job-log');
var dbResult = require('./db-result');
var serializeError = require('serialize-error');

module.exports = function failed(job, err) {
  logger('failed:  [' + job.id + ']');
  logger('error', err);

  var logType = enums.log.error;
  var isRetry = job.retryCount < job.retryMax;
  var isRepeating = is.repeating(job);
  var dateEnable = new Date();

  job.status = enums.status.terminated;

  if (isRetry) {
    job.status = enums.status.failed;
    dateEnable = datetime.add.ms(job.retryDelay * job.retryCount);
    job.retryCount++;
    logType = enums.log.warning;
  }

  if (!isRetry && isRepeating) {
    job.status = enums.status.waiting;
    dateEnable = datetime.add.ms(job.repeatDelay);
    job.retryCount = 0;
  }

  job.dateFinished = new Date();
  job.progress = 0;
  var duration = job.dateFinished - job.dateStarted;
  duration = duration >= 0 ? duration : 0;

  var errAsString = serializeError(err);

  var logFailed = jobLog.createLogObject(job, errAsString, enums.message.failed, logType, job.status);
  logFailed.duration = duration;
  logFailed.errorMessage = err && err.message ? err.message : enums.message.noErrorMessage;
  logFailed.errorStack = err && err.stack ? err.stack : enums.message.noErrorStack;

  var sliceLogs = job.log.length >= job.q.limitJobLogs;
  var logTruncated = jobLog.createLogObject(job, 'Retaining ' + job.q.limitJobLogs + ' log entries', enums.message.jobLogsTruncated, enums.log.information, job.status);

  return Promise.resolve().then(function () {
    return job.q.r.db(job.q.db).table(job.q.name).get(job.id).update({
      status: job.status,
      retryCount: job.retryCount,
      progress: job.progress,
      dateFinished: job.dateFinished,
      dateEnable: dateEnable,
      log: job.q.r.branch(sliceLogs, job.q.r.row('log').append(logFailed).append(logTruncated).slice(-job.q.limitJobLogs), job.q.r.row('log').append(logFailed)),
      queueId: job.q.id
    }, { returnChanges: true }).run(job.q.queryRunOptions);
  }).then(function (updateResult) {
    logger('updateResult', updateResult);
    return dbResult.toIds(updateResult);
  }).then(function (jobIds) {
    if (isRetry || isRepeating) {
      logger('Event: failed', job.q.id, jobIds[0]);
      job.q.emit(enums.status.failed, job.q.id, jobIds[0]);
    } else {
      logger('Event: terminated', job.q.id, jobIds[0]);
      job.q.emit(enums.status.terminated, job.q.id, jobIds[0]);
    }
    if (!isRetry && !isRepeating && is.true(job.q.removeFinishedJobs)) {
      return job.q.removeJob(job).then(function (deleteResult) {
        return jobIds;
      });
    } else {
      return jobIds;
    }
  });
};