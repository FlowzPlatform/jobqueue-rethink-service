'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = require('./logger')(module);
var uuid = require('uuid');
var enums = require('./enums');
var is = require('./is');
var errorBooster = require('./error-booster');
var jobOptions = require('./job-options');
var jobProgress = require('./job-progress');
var jobUpdate = require('./job-update');
var jobLog = require('./job-log');

var Job = function () {
  function Job(q, jobData) {
    _classCallCheck(this, Job);

    logger('constructor');
    logger('queue id', q.id);
    logger('jobData', jobData);
    this.q = q;

    if (is.job(jobData)) {
      logger('Creating job from data');
      Object.assign(this, jobData);
      this.priority = enums.priorityFromValue(this.priority);
    } else {
      logger('Creating new job from defaults');

      var options = jobOptions();
      var now = new Date();
      var newId = uuid.v4();
      this.id = newId;
      this.name = options.name || newId;
      this.priority = options.priority;
      this.timeout = options.timeout;
      this.retryDelay = options.retryDelay;
      this.retryMax = options.retryMax;
      this.retryCount = 0;
      this.repeat = options.repeat;
      this.repeatDelay = options.repeatDelay;
      this.processCount = 0;
      this.progress = 0;
      this.status = enums.status.created;
      this.log = [];
      this.dateCreated = now;
      this.dateEnable = now;
      this.dateStarted = null;
      this.dateFinished = null;
      this.queueId = q.id;
      // Conflicting job options will be overwritten.
      if (is.function(jobData)) {
        throw new Error(enums.message.jobDataInvalid);
      }
      if (is.array(jobData) || !is.object(jobData)) {
        this.data = jobData;
      } else {
        Object.assign(this, jobData);
      }
    }
  }

  _createClass(Job, [{
    key: 'setName',
    value: function setName(newName) {
      if (is.string(newName)) {
        this.name = newName;
        return this;
      }
      throw new Error(enums.message.nameInvalid);
    }
  }, {
    key: 'setPriority',
    value: function setPriority(newPriority) {
      if (Object.keys(enums.priority).includes(newPriority)) {
        this.priority = newPriority;
        return this;
      }
      throw new Error(enums.message.priorityInvalid);
    }
  }, {
    key: 'setTimeout',
    value: function setTimeout(newTimeout) {
      if (is.integer(newTimeout) && newTimeout >= 0) {
        this.timeout = newTimeout;
        return this;
      }
      throw new Error(enums.message.timeoutIvalid);
    }
  }, {
    key: 'setRetryMax',
    value: function setRetryMax(newRetryMax) {
      if (is.integer(newRetryMax) && newRetryMax >= 0) {
        this.retryMax = newRetryMax;
        return this;
      }
      throw new Error(enums.message.retryMaxIvalid);
    }
  }, {
    key: 'setRetryDelay',
    value: function setRetryDelay(newRetryDelay) {
      if (is.integer(newRetryDelay) && newRetryDelay >= 0) {
        this.retryDelay = newRetryDelay;
        return this;
      }
      throw new Error(enums.message.retryDelayIvalid);
    }
  }, {
    key: 'setRepeat',
    value: function setRepeat(newRepeat) {
      if (is.boolean(newRepeat) || is.integer(newRepeat) && newRepeat >= 0) {
        this.repeat = newRepeat;
        return this;
      }
      throw new Error(enums.message.repeatInvalid);
    }
  }, {
    key: 'setRepeatDelay',
    value: function setRepeatDelay(newRepeatDelay) {
      if (is.integer(newRepeatDelay) && newRepeatDelay >= 0) {
        this.repeatDelay = newRepeatDelay;
        return this;
      }
      throw new Error(enums.message.repeatDelayInvalid);
    }
  }, {
    key: 'setDateEnable',
    value: function setDateEnable(newDateEnable) {
      if (is.date(newDateEnable)) {
        this.dateEnable = newDateEnable;
        return this;
      }
      throw new Error(enums.message.dateEnableIvalid);
    }
  }, {
    key: 'updateProgress',
    value: function updateProgress(percent) {
      var _this = this;

      logger('updateProgress [' + percent + ']');
      return this.q.ready().then(function () {
        return jobProgress(_this, percent);
      }).catch(errorBooster(this, logger, 'updateProgress'));
    }
  }, {
    key: 'update',
    value: function update() {
      var _this2 = this;

      logger('update');
      return this.q.ready().then(function () {
        return jobUpdate(_this2);
      }).catch(errorBooster(this, logger, 'update'));
    }
  }, {
    key: 'getCleanCopy',
    value: function getCleanCopy(priorityAsString) {
      logger('getCleanCopy');
      var jobCopy = Object.assign({}, this);
      if (!priorityAsString) {
        jobCopy.priority = enums.priority[jobCopy.priority];
      }
      delete jobCopy.q;
      return jobCopy;
    }
  }, {
    key: 'addLog',
    value: function addLog() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : enums.message.seeLogData;

      var _this3 = this;

      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : enums.log.information;
      var status = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.status;

      logger('addLog', data, message, type, status);
      return this.q.ready().then(function () {
        return jobLog.commitLog(_this3, data, message, type, status);
      }).catch(errorBooster(this, logger, 'addLog'));
    }
  }, {
    key: 'getLastLog',
    value: function getLastLog() {
      return jobLog.getLastLog(this);
    }
  }]);

  return Job;
}();

module.exports = Job;