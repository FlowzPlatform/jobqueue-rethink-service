'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var logger = require('./logger')(module);
var Promise = require('bluebird');
var is = require('./is');
var enums = require('./enums');
var dbResult = require('./db-result');
var jobParse = require('./job-parse');

module.exports = function cancelJob(q, jobOrId, reason) {
  logger('cancelJob', jobOrId, reason);

  return Promise.resolve().then(function () {
    return jobParse.id(jobOrId);
  }).then(function (ids) {
    var _q$r$db$table;

    return (_q$r$db$table = q.r.db(q.db).table(q.name)).getAll.apply(_q$r$db$table, _toConsumableArray(ids)).update({
      status: enums.status.cancelled,
      dateFinished: new Date(),
      log: q.r.row('log').append({
        date: new Date(),
        queueId: q.id,
        type: enums.log.information,
        status: enums.status.cancelled,
        retryCount: q.r.row('retryCount'),
        processCount: q.r.row('processCount'),
        message: reason
      }),
      queueId: q.id
    }, { returnChanges: true }).run(q.queryRunOptions);
  }).then(function (updateResult) {
    logger('updateResult', updateResult);
    return dbResult.toIds(updateResult);
  }).then(function (jobIds) {
    jobIds.forEach(function (jobId) {
      logger('Event: cancelled', q.id, jobId);
      q.emit(enums.status.cancelled, q.id, jobId);
    });
    if (is.true(q.removeFinishedJobs)) {
      return q.removeJob(jobIds).then(function (deleteResult) {
        logger('Removed finished jobs on cancel [' + deleteResult + ']');
        return jobIds;
      });
    } else {
      return jobIds;
    }
  });
};