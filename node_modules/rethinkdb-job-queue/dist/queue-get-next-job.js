'use strict';

var logger = require('./logger')(module);
var Promise = require('bluebird');
var enums = require('./enums');
var dbResult = require('./db-result');

module.exports = function queueGetNextJob(q) {
  logger('getNextJob');
  logger('Concurrency: [' + q.concurrency + '] Running: [' + q.running + ']');
  var quantity = q.concurrency - q.running;
  logger('Query Limit: [' + quantity + ']');
  if (quantity < 1) {
    return Promise.resolve([]);
  }
  return Promise.resolve().then(function () {
    return q.r.table(q.name).orderBy({ index: enums.index.indexInactivePriorityDateCreated }).limit(quantity).filter(q.r.row('dateEnable').le(q.r.now())).update(getJobUpdate(q), { returnChanges: true }).default({}).run(q.queryRunOptions);
  }).then(function (updateResult) {
    logger('updateResult', updateResult);
    return dbResult.toJob(q, updateResult);
  }).then(function (updatedJobs) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = updatedJobs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var job = _step.value;

        logger('Event: active [' + job.id + ']');
        q.emit(enums.status.active, q.id, job.id);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return updatedJobs;
  });
};

function getJobUpdate(q) {
  return function (job) {
    return q.r.branch(job('status').ne(enums.status.active), {
      status: enums.status.active,
      dateStarted: q.r.now(),
      dateEnable: q.r.now().add(job('timeout').div(1000)).add(job('retryDelay').div(1000).mul(job('retryCount'))),
      queueId: q.id,
      processCount: job('processCount').add(1),
      log: job('log').append({
        date: q.r.now(),
        queueId: q.id,
        type: enums.log.information,
        status: enums.status.active,
        retryCount: job('retryCount'),
        processCount: job('processCount'),
        message: enums.message.active
      })
    }, null);
  };
}