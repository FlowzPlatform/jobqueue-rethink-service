'use strict';

var logger = require('./logger')(module);
var Promise = require('bluebird');
var enums = require('./enums');
var uuid = require('uuid');
var hostname = require('os').hostname();
var dbAssert = require('./db-assert');
var dbReview = require('./db-review');
var queueChange = require('./queue-change');
var dbDriver = require('./db-driver');

module.exports.attach = function dbAttach(q, cxn) {
  logger('attach');
  q._r = dbDriver(cxn);
  q._host = q.r._poolMaster._options.host;
  q._port = q.r._poolMaster._options.port;
  q._db = q.r._poolMaster._options.db;
  q._id = [hostname, q._db, q.name, process.pid, uuid.v4()].join(':');
  q._ready = dbAssert(q).then(function () {
    if (q.changeFeed) {
      return q.r.db(q.db).table(q.name).changes().run(q.queryRunOptions).then(function (changeFeed) {
        q._changeFeedCursor = changeFeed;
        return q._changeFeedCursor.each(function (err, change) {
          return queueChange(q, err, change);
        });
      });
    }
    q._changeFeedCursor = false;
    return null;
  }).then(function () {
    if (q.master) {
      logger('Queue is a master');
      return dbReview.enable(q);
    }
    return null;
  }).then(function () {
    logger('Event: ready [' + q.id + ']');
    q.emit(enums.status.ready, q.id);
    return true;
  });
  return q._ready;
};

module.exports.detach = function dbDetach(q) {
  logger('detach');
  return Promise.resolve().then(function () {
    if (q._changeFeedCursor) {
      var feed = q._changeFeedCursor;
      q._changeFeedCursor = false;
      logger('closing changeFeed');
      return feed.close();
    }
    return true;
  }).then(function () {
    if (q.master) {
      logger('disabling dbReview');
      return dbReview.disable(q);
    }
    return true;
  });
};

module.exports.drain = function drain(q) {
  return Promise.resolve().then(function () {
    q._ready = Promise.resolve(false);
    logger('draining connection pool');
    return q.r.getPoolMaster().drain();
  }).delay(1000).then(function () {
    logger('Event: detached [' + q.id + ']');
    q.emit(enums.status.detached, q.id);
  }).delay(1000).then(function () {
    q.eventNames().forEach(function (key) {
      q.removeAllListeners(key);
    });
    return true;
  });
};